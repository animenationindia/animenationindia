<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anime List - Anime Nation India</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header class="header">
    <nav class="nav-wrap">
      <a href="index.html" class="brand">
        <div class="brand-logo"><img src="ani-logo.png" style="width:100%;height:100%;object-fit:cover;border-radius:18px;" alt="Logo"></div>
        <div class="brand-text"><span class="brand-title">Anime Nation India</span><span class="brand-sub">Go Back to Home</span></div>
      </a>
    </nav>
  </header>

  <main class="page-wrap" style="padding-top: 8rem; min-height: 80vh;">
    <a href="index.html" style="color: var(--accent); text-decoration: none; font-weight: 600; margin-bottom: 20px; display: inline-block;"><i class="fas fa-arrow-left"></i> Back to Home</a>
    <div class="section-head">
      <div>
        <h2 class="section-title" id="pageTitle" style="font-size: 2rem;">Loading Data...</h2>
        <p class="section-sub" id="pageSub">Fetching from API...</p>
      </div>
    </div>
    
    <div id="wrapperContainer" class="grid-wrap"></div>
  </main>

  <div class="anime-modal-backdrop" id="animeModal">
    <div class="anime-modal">
      <button class="modal-close" id="modalCloseBtn"><i class="fas fa-times"></i></button>
      <div class="modal-layout">
        <div class="modal-cover-wrap"><img id="modalPoster" src="" class="modal-poster" alt="Poster"></div>
        <div class="modal-content">
          <h2 id="modalTitle" class="modal-title"></h2>
          <div class="modal-badges-row" style="display: flex; gap: 0.5rem; margin-top: 0.3rem; margin-bottom: 0.6rem; font-size: 0.8rem; font-weight: 700; flex-wrap: wrap;">
             <span style="background: #ffdd95; color: #000; padding: 0.15rem 0.4rem; border-radius: 4px;">HD</span>
             <span style="background: #b0e3af; color: #000; padding: 0.15rem 0.4rem; border-radius: 4px;"><i class="fas fa-closed-captioning"></i> <span id="modalEpSub">0</span></span>
             <span style="color: var(--text-muted); font-weight: 400;">‚Ä¢</span><span id="modalFormat" style="color: var(--text-muted);">TV</span>
             <span style="color: var(--text-muted); font-weight: 400;">‚Ä¢</span><span id="modalDurationBadge" style="color: var(--text-muted);">24m</span>
          </div>
          <p id="modalMeta" class="modal-meta" style="margin-bottom: 0.5rem;"></p>
          <div class="modal-tags" id="modalTags"></div>
          <div class="modal-actions" style="margin-top: 1rem; margin-bottom: 1rem;">
            <a id="modalAniListLink" href="https://animeyy.com/" target="_blank" class="btn-primary" style="background: linear-gradient(135deg, #ff4dd2, #ffd54a); color: #050716; padding: 0.7rem 1.8rem;"><i class="fas fa-play-circle"></i> Watch Now</a>
          </div>
          <p id="modalSummary" class="modal-summary"></p>
        </div>
      </div>
    </div>
  </div>

  <script>
    const ANILIST_ENDPOINT = "https://graphql.anilist.co";
    const container = document.getElementById("wrapperContainer");

    function getSeason() {
      const m = new Date().getMonth();
      if (m >= 0 && m <= 2) return "WINTER"; if (m >= 3 && m <= 5) return "SPRING";
      if (m >= 6 && m <= 8) return "SUMMER"; return "FALL";
    }

    // Modal Handle
    const aModal = document.getElementById("animeModal");
    function openModalLocal(anime) {
      document.getElementById("modalPoster").src = anime.poster;
      document.getElementById("modalTitle").textContent = anime.title;
      document.getElementById("modalEpSub").textContent = anime.episodes || "?";
      document.getElementById("modalFormat").textContent = anime.format || "TV";
      document.getElementById("modalDurationBadge").textContent = (anime.duration || 24) + "m";
      document.getElementById("modalMeta").textContent = `${anime.studio} ‚Ä¢ ${anime.releaseDate}`;
      document.getElementById("modalSummary").textContent = anime.synopsis;
      const tagsContainer = document.getElementById("modalTags"); tagsContainer.innerHTML = "";
      (anime.genre || "").split(",").forEach(g => { if(g.trim()){ const s = document.createElement("span"); s.textContent = g.trim(); tagsContainer.appendChild(s); } });
      aModal.classList.add("open");
    }
    document.getElementById("modalCloseBtn").onclick = () => aModal.classList.remove("open");
    aModal.onclick = (e) => { if(e.target===aModal) aModal.classList.remove("open"); };
    document.addEventListener("keydown", e => { if (e.key === "Escape") aModal.classList.remove("open"); });

    // Card Creators
    function createSimpleCard(anime) {
      const statusClass = (anime.status||"").toLowerCase().includes("completed") ? "badge-completed" : (anime.status||"").toLowerCase().includes("upcoming") ? "badge-upcoming" : "badge-ongoing";
      const safeObj = JSON.stringify(anime).replace(/'/g, "\\'").replace(/"/g, "&quot;");
      return `<article class="anime-card" onclick='openModalLocal(${safeObj})'>
        <img src="${anime.poster}" class="anime-card-img" loading="lazy" alt="Poster">
        <div class="anime-card-body"><h3 class="anime-name">${anime.title}</h3><div class="anime-meta-row"><span>${(anime.genre||"Anime").split(",")[0]}</span><span class="badge-status ${statusClass}">${anime.status}</span></div><div class="anime-meta-row" style="margin-top:.2rem;"><span><i class="fas fa-star" style="color:#ffd54a;margin-right:.25rem;"></i>${anime.rating}/10</span><span>${anime.episodes||0} eps</span></div></div></article>`;
    }

    function createTopRow(anime, index) {
      const safeObj = JSON.stringify(anime).replace(/'/g, "\\'").replace(/"/g, "&quot;");
      const tags = (anime.genre||"").split(",").slice(0,3).map(g=>`<span class="top-tag-pill">${g.trim()}</span>`).join("");
      const seasonStr = anime.season ? anime.season.charAt(0) + anime.season.slice(1).toLowerCase() : "";
      return `<div class="top-row-card" onclick='openModalLocal(${safeObj})'>
        <div class="top-rank">#${index}</div><img src="${anime.poster}" class="top-img" alt="Poster">
        <div class="top-info"><div class="top-title-row">${anime.title}</div><div class="top-tags-row">${tags}</div></div>
        <div class="top-stats"><div class="score"><i class="fas fa-smile"></i> ${anime.scoreInt||80}%</div></div>
        <div class="top-format">${(anime.format||"TV").replace("_"," ")}<br>${anime.episodes||0} eps</div>
        <div class="top-season">${seasonStr} ${anime.releaseDate||""}</div>
      </div>`;
    }

    /* =================================
       API FETCHERS (DUAL API) 
       ================================= */

    // 1. ANILIST FETCH
    async function fetchFromAnilist(variables) {
      const query = `query ($page: Int, $perPage: Int, $sort: [MediaSort], $format: MediaFormat, $status: MediaStatus, $search: String, $season: MediaSeason, $seasonYear: Int) {
          Page(page: $page, perPage: $perPage) {
            media(type: ANIME, sort: $sort, format: $format, status: $status, search: $search, season: $season, seasonYear: $seasonYear, isAdult: false) {
              id title{romaji english} coverImage{large} genres episodes averageScore status duration startDate{year} season format studios(isMain:true){nodes{name}} description(asHtml:false)
            } } } }`;
      const res = await fetch(ANILIST_ENDPOINT, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ query, variables }) });
      const json = await res.json();
      return (json.data.Page.media || []).map(m => {
        let st = m.status==="FINISHED"?"Completed":m.status==="NOT_YET_RELEASED"?"Upcoming":"Ongoing";
        return {
          id:m.id, title: m.title.english || m.title.romaji, genre: (m.genres||[]).join(", "),
          poster: m.coverImage.large, synopsis: m.description ? m.description.replace(/<[^>]*>/g,"") : "No summary available.",
          status: st, episodes: m.episodes || "?", rating: m.averageScore?(m.averageScore/10).toFixed(1):"8.0", scoreInt: m.averageScore,
          duration: m.duration || 24, releaseDate: m.startDate?.year || "", season: m.season || "",
          studio: m.studios?.nodes?.[0]?.name || "Unknown", format: m.format || "TV"
        };
      });
    }

    // 2. JIKAN (MAL) FETCH
    async function fetchFromJikan(genreId) {
      const res = await fetch(`https://api.jikan.moe/v4/anime?genres=${genreId}&order_by=members&sort=desc&sfw=true`);
      const json = await res.json();
      return (json.data || []).map(m => {
        let st = m.status==="Finished Airing"?"Completed":m.status==="Not yet aired"?"Upcoming":"Ongoing";
        return {
          id: m.mal_id, title: m.title_english || m.title, genre: (m.genres||[]).map(g=>g.name).join(", "),
          poster: m.images.webp.large_image_url, synopsis: m.synopsis ? m.synopsis.replace(/<[^>]*>/g,"") : "No summary available.",
          status: st, episodes: m.episodes || "?", rating: m.score ? m.score.toFixed(1) : "8.0", scoreInt: m.score ? Math.round(m.score*10) : 80,
          duration: m.duration ? m.duration.replace(" per ep", "") : "24 min", releaseDate: m.year || "", season: m.season || "",
          studio: m.studios?.[0]?.name || "Unknown", format: m.type || "TV"
        };
      });
    }

    async function initPage() {
      const params = new URLSearchParams(window.location.search);
      const type = params.get("type");
      const val = params.get("val");
      const genreId = params.get("id");
      const genreName = params.get("name");
      
      let title = "Results", sub = "Fetched from API.";
      let isJikan = false;
      let vars = { page: 1, perPage: 40 };

      // Route Requests
      if (type === "trending") { vars.sort = ["TRENDING_DESC"]; title = "üî• Trending Now"; sub="Top trending from AniList.";}
      else if (type === "popularSeason") { vars.season = getSeason(); vars.seasonYear = new Date().getFullYear(); vars.sort = ["POPULARITY_DESC"]; title = "‚≠ê Popular This Season"; sub="AniList.";}
      else if (type === "upcoming") { vars.status = "NOT_YET_RELEASED"; vars.sort = ["POPULARITY_DESC"]; title = "üìÖ Upcoming Next Season"; sub="AniList.";}
      else if (type === "allTimePopular") { vars.sort = ["POPULARITY_DESC"]; title = "üåü All Time Popular"; sub="AniList.";}
      else if (type === "topRated") { vars.sort = ["SCORE_DESC", "POPULARITY_DESC"]; title = "üèÜ Top 100 Anime"; sub="AniList.";}
      else if (type === "search") { vars.search = val; vars.sort = ["POPULARITY_DESC"]; title = `üîç Search: "${val}"`; sub="AniList.";}
      else if (type === "genre_jikan") { isJikan = true; title = `üè∑Ô∏è Category: ${genreName}`; sub="Powered by MyAnimeList (Jikan API).";}

      document.getElementById("pageTitle").textContent = title;
      document.getElementById("pageSub").textContent = sub;

      try {
        let data = isJikan ? await fetchFromJikan(genreId) : await fetchFromAnilist(vars);
        if(!data.length) { container.innerHTML = "<div style='color:var(--text-muted); padding:2rem;'>No results found.</div>"; return; }

        if(type === "topRated") {
          container.className = "top-list-wrap";
          container.innerHTML = data.map((a, i) => createTopRow(a, i+1)).join("");
        } else {
          container.className = "grid-wrap";
          container.innerHTML = data.map(createSimpleCard).join("");
        }
      } catch(e) {
        container.innerHTML = `<div style="color:var(--danger); padding:2rem;">‚ùå Error fetching data. Please check your internet connection or try again later.</div>`;
      }
    }
    initPage();
  </script>
</body>
</html>
